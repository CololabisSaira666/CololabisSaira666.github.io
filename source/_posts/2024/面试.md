---
title: 面试
date: 2024-08-21 16:28:24
tags:
  - 学些有趣的
categories:
  - Java
top: 7  
---

整理关于Java面试时可能会问的基础问题。

# 问题

## Java 面向对象的特征

封装：隐藏类里面的实际操作，可以重复使用

继承：增加代码复用性

多态：增强代码可以移植性，健壮性，两个类有继承关系

## ArrayList 和LinkedList的区别

|            | 时间复杂度 |      |
| ---------- | ---------- | ---- |
| ArrayList  | O(1)       |      |
| LinkedList | O(n)       |      |

LinkedList:插入更快，但需要更多的内存

ArrayList：查找快，但不适用于多次增加与删除

## 高并发中的集合有哪些问题

高并发：电梯调度？？？

**集合：**是否线程安全

- 安全：Vector、Hashtable（第一代，安全但是效率低下）
- 非安全：ArrayList、Hashmap（第二代）

**第三代线程安全集合：**关于Synchronized锁和lock锁

## JDK1.8的新特性

接口的默认方法：Java中只有单继承

## 接口和抽象类的区别

抽象类：更多描述抽象的概念。

接口：描述特性捏

## ==和equals的区别

==：比较基本数据类型的数值是否相等，引用数据类型的对象是否相等。

equals：比较两个对象的类型是否相同。（注意重写）

## 异常处理机制

抛出：

捕获：

声明：

## 重载和重写的区别

重载：发生在父类和子类之间

重写：方法。

## StringBuffer和StringBuilder

StringBuilder：在单线程环境下使用

## 如何声明一个类不会被继承，不会有子类

被final修饰

## JVM

一些安全性的信息，一般情况下不能离开JVM。**沙箱安全机制**

- 类加载器隔离
- 字节码验证
- 安全管理器
- 异常处理
- 线程安全

### 内存溢出/内存泄漏

长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄露。

<font color = blue>a **memory leak** with Java</font>



### GC

垃圾回收是 JVM 管理内存的一部分。

#### JVM的垃圾回收算法



## 序列化

将对象的状态转换为字节流的过程。<u>将对象保存到文件、数据库或通过网络传输</u>。反序列化则是将字节流恢复为对象。

在分布式系统中传输对象数据。

### transient 关键字

transient变量不会贯穿对象的序列化和反序列化，生命周期仅存于调用者的内存中，而不会写到磁盘里进行持久化。

**static修饰的静态变量天然就是不可序列化的。**

序列化保存的是对象状态，静态变量保存的是类状态。

## JWT



# 写代码

## 字符串

**仅保留字母、数字、特殊字符等**

replaceAll("[\^a-zA-Z]", "")；

```java
public static void main(String[] args) {
    String str = "测 试 WG23-D";
    // 只留字母
    String s1 = str.replaceAll("[^a-zA-Z]", "");
    // 只留数字
    String s2 = str.replaceAll("[^0-9]", "");
    // 只留中文
    String s3 = str.replaceAll("[^\u4e00-\u9fa5]", "");
    System.out.println("s1 = " + s1); // WGD
    System.out.println("s2 = " + s2); // 23
    System.out.println("s3 = " + s3); // 测试
}
```

## 输入

在算法题需要自己处理输入输出的时候还是挺重要的，参考链接：https://blog.csdn.net/WB18002337539/article/details/119486489



## 双端队列Deque

熟悉一下这个类，双端的，与stack对比。

## 位运算

Brian Kernighan 算法

## Arrays.sort()的三种常用用法

**Arrays.sort(int[] a)** 

```java
 public class Main {
	public static void main(String[] args) { 	
  	int[] a = {9, 8, 7, 2, 3, 4, 1, 0, 6, 5};
    Arrays.sort(a);
    for(int i = 0; i < a.length; i ++) {
         System.out.print(a[i] + " "); // 0 1 2 3 4 5 6 7 8 9
    }
}
```

**Arrays.sort(int[] a, int fromIndex, int toIndex)**: 这种形式是对数组部分排序，也就是对数组a的下标从fromIndex到toIndex-1的元素排序，注意：下标为toIndex的元素不参与排序哦！

**实现降序排列**

```java
public class Main {
    public static void main(String[] args){
      	//不能使用基本数据类型
        Integer[] arr = {5,4,7,9,2,12,54,21,1};
        //降序
        Arrays.sort(arr, (a, b) -> {
            //返回值>0交换
            return b-a;
        });
        System.out.println(Arrays.toString(arr));
    }
}
```

## 快排

```Java
public class Main {
    static public void main(String[] args) {
        int[] nums = {3,2,1,5,6,4};
        findKthLargest(nums);
    }
    static public void findKthLargest(int[] nums) {
        int length = nums.length;
        quickSort(nums, 0, length-1);
        System.out.println(Arrays.toString(nums));
    }

    static public void quickSort(int[] array, int l, int r) {
        if(l < r) {
            int pos = getPos(array, l, r);
            quickSort(array, l, pos-1);
            quickSort(array, pos+1, r);
        }
    }

    static public int getPos(int[] array, int l, int r) {
        int flag_num = array[r];
        int point = l;
        for (int i = l; i < r; i++) {
            if (array[i] <= flag_num) {
                int temp = array[i];
                array[i] = array[point];
                array[point] = temp;
                point++;
            }
        }
        int temp = array[point];
        array[point] = array[r];
        array[r] = temp;
        return point;
    }
}
```

## PriorityQueue（Java优先级队列）

关于实现大小堆