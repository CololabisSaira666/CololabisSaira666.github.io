---
title: OO总结
categories:
  - Java
tags:
  - 课程收获
  - 面向对象
mathjax: true
cover: https://miaomiao-1-1319022947.cos.ap-beijing.myqcloud.com/202402020253.jpg
abbrlink: 5ecef886
date: 2024-06-14 23:13:35
---

这是本人的2024年OO课程总结，我是北航6系的一个普通学生，编码水平一般，仅以普通生身份评价OO课程。

首先，2023年春我第一次选OO，由于本人此前未选过OOpre，且无Java编程经验，首次作业完全不会做。不是很愿意回忆第一次上课的情景，总之就是非常差劲。

本学期的OO，我究竟学到了什么？我也不知道，或许还不如多去练习算法与面试题。也罢，都过去了。

# 第一单元

## 需求分析

第一单元主任务：单变量多项式的括号展开。

在hw1中，仅需将一个包含+、-、*、^以及括号（单层）的单变量表达式，输出展开所有括号的结果。

hw2新增了多层括号，自定义函数因子和指数函数因子。

hw3新增求导算子。

## 代码架构

### hw1

采用了递归下降法。一个表达式可以拆分成若干项（由+、-符号连接），因子可以分为表达式因子，数字和幂函数。在完全化简后，表达式由若干以下项构成。
$$
c*x^n
$$
我的主要思路是，先解析表达式，再利用基本项的性质运算，最后输出。

Factor接口下的类是递归下降方法的核心。Power类存储形如$c*x^n$的项，Poly类负责运算工作。

Poly类的基本复杂度较高，大概是因为我将全部的运算，以及部分输出表达式工作写在了Poly里。

### hw2

在第一次作业的基础上，新增了自定义函数类。对于输入表达式中的的自定义函数，采取带入实参替换的方式预处理。修改Power类的定义，用hashmap存储exp。修改Poly类，新增有关exp的运算。

需要注意，在替换时处理exp与x的关系，以及先将形参替换成其他字母，再替换实参。复杂度问题与hw1类似。

### hw3

新增求导算子。这部分需要注意的问题是：dx可以多次出现，以及正确使用链式法则。我最大的问题是，把求导方法也写进了power类里，而没有采用类似第二次上机的架构，即递归实现求导功能。类复杂度图也能反映出这个问题。

## bug们

三次作业在强测和互测中均没有出现bug。

自己测出来/跑评测机发现的bug如下：

- hw1：因为没有仔细分析形式化表述，未考虑形如$x^{+1}$的情况。

- hw2：在输出exp时是否要格外加括号的判定问题。

- hw3：一开始没有注意到，dx可以多次出现。

互测：

- hw1：同房的一位同学在处理输出结果时的bug，如果末位项为1，会无法输出1。

- hw2与hw3：没有hack到。

## 不存在的优化

**hw1：**需要优化的部分是，尽量不让首项为负。如x-1优于-1+x。

**hw2：**比较容易想到和实现的是，输出exp时判断是否需要格外加括号。比较复杂的是指数函数的优化。看了评论区的优化方法，但因为能力有限，且考虑到可能的bug，选择正确性优先。这也导致后两次作业性能分惨淡。

**hw3：**未考虑。

## 总结

第一单元有惊无险结束，非常感谢助教、开发评测机的同学、以及hw2与我交流相同测试点问题的同学们。希望我在下一单元的多线程学习中有更多收获。

# 第二单元

## 需求分析

**第二单元主任务：模拟多线程实时电梯系统。**

hw1：楼座内有6部电梯，接收乘客请求，并合理调度将其送到目的地。请求中包括乘客期待进入的电梯，电梯需要实时反馈运行情况（移动、开关门、乘客进出）。

hw2：新增电梯重置请求，电梯重置时可以改变最大容量和移动时间；乘客请求中不再添加电梯id，由调度器分配；电梯移动接乘客前需发receive指令，否则视为非法移动。

hw3：新增电梯重置为双轿厢请求，双轿厢电梯可以设置换成层。

## 代码架构

三次作业中，我创建多线程的方法均为：声明一个Thread类的子类，在子类中重写Thread类的run方法。

均使用了synchronized关键字修饰方法，未使用其他类型的锁。

### hw1

分析题目后，我设计的电梯系统运行逻辑如下：每部电梯有一个等候队列和轿厢内队列。等候队列存储”期望上这部电梯，但还没乘上“的乘客请求，轿厢内队列存储”已在轿厢内“的乘客需求。初始时刻，电梯停在一层，默认移动方向向上，若等候队列暂时没有乘客请求，且电梯内也没有乘客，该线程会wait，直到有新请求时被唤醒。若电梯在移动中，在每一层会检测乘客状态，检测是否有乘客需要进出电梯，若有，则当前层开门，若无，则继续前往下一层。电梯若有开门动作，先检测电梯内是否有乘客离开，若电梯还有空位，会依次让本层的等待乘客上电梯。电梯在到达最底层或最高层后，改变运行方向；或电梯沿当前运行方向无法到达等候乘客所在层，且电梯内无乘客，也会改变运行方向。

在讨论中，有同学提到了如下场景：电梯在某层接到乘客，在乘客关门后，电梯开始前往下一楼层时，突然该层到达了大量请求，电梯是否需要折返接人（以争取更短的总运行时间）。根据实际生活经验，电梯应该继续沿原路线运行，不能为了优化（一些情况下有可能用时更短）而放弃更符合认知逻辑的调度策略是不正确的。

电梯的等待队列，即Request中用到了锁，调度器向电梯分配请求，以及电梯查看请求过程中涉及线程交互。

Elevator类的基本复杂度较高，大概是因为我将电梯的运行控制（方向、开关门等）写在了一起。

### hw2

在第一次作业的基础上，新增电梯重置请求，电梯重置时可以改变最大容量和移动时间；乘客请求中不再添加电梯id，由调度器分配；电梯移动接乘客前需发receive指令，否则视为非法移动。程序的基本架构未改变。

需要注意，本次乘客不指定乘坐某部电梯。经过思考与尝试，我认为新的调度器有两种解决方法：1.输入请求，查看6部电梯哪一部能最快接到该乘客（通过乘客所在楼层，6部电梯是否满载、楼层与运行方向确定），优点是在乘客依次到来时，能够尽量减少每位乘客的等待时间，但需要合理化调度策略，避免出错（如乘客数较多时，一些乘客可能无法被接上）。2.随机策略，通过随机生成电梯id的方法为乘客选择搭乘电梯，优点为，当大批乘客迅速到来时，随机分配时可能会拥有更好的性能，缺点为乘客请求数较少时，随即策略可能会导致一台电梯频繁工作。

电梯重置时，要锁住等待队列，使其无法被加入新请求。

同样的，Elevator类的基本复杂度较高。

### hw3

双轿厢调度问题。在本次作业中，我采取了一个电梯分裂为两个电梯的策略，而非在程序开始时设置12个电梯线程，按需获取。本方法的优点是方便debug，缺点是牺牲了性能，策略非最优。

## bug们

### hw1

注意边界条件判定，电梯一开始会前往0或12层。

### hw2

在大量乘客在同一时间到来时，可能出现乘客进入电梯后才receive的情况（不太容易复现）。

### hw3

A、B轿厢在换乘楼层相撞。解决方法为，双轿厢电梯都不会在换乘层停留，在换层接到或放下乘客后会立刻离开。

电梯被重置为双轿厢后，未开始重置，却发出receive-A/B的指令。检查后发现，此时电梯等待队列未锁住，还可以添加请求。

## 总结

**线程安全：**共享。本次作业中，涉及线程安全的部分为请求。调度器需要拿取请求分配给合适的线程，调度器的某些行为也要依靠线程反馈，关键是处理好他们的共享变量。保证线程安全的方法是使用synchronized（自动锁，锁的创建和释放都是自动的）、或者使用锁（lock，手动指定锁的创建和释放），或者用volatile关键字。本单元中只使用了第一种，在使用过程中要注意范围，避免不必要的性能消耗。

**层次化设计：**Elevator类仅处理电梯运行逻辑，不要夹杂调度模块。应该分为接收请求、分配请求、执行请求三个部分，使代码有较高的可读性和逻辑性。可采用生产者-消费者模式。

其他：第二单元结束，我和我愚蠢的电梯顺利通过三次强测。虽说三次强测都没有bug，勉强通过，但我明白，这是架构与程序可读性换来的，写最后一次作业时，我在迭代时能明显感觉到代码可读性变差。我还需要提升代码能力，在完成任务的基础上写出更好的代码。第三单元，预启动。

# 第三单元

## 测试过程

**黑箱测试：**也称功能测试，通过测试来检测每个功能是否都能正常使用。 在测试中，在完全不考虑程序内部结构和内部特性的情况下，在程序接口处进行测试。黑箱测试只检查程序功能是否符合需求规格说明书。

**白箱测试：**又称为结构测试或逻辑驱动测试，它是把测试对象看成一个透明的盒子。测试人员需要利用程序内部的逻辑结构设计测试用例，对程序所有逻辑路径进行测试。白箱测试分为：静态测试方法、动态测试方法。

**单元测试：**对软件中的最小可测试部分，如单个函数或方法进行验证和测试。每个测试只关注一个特定的单元，不依赖于系统其他部分的状态。

**功能测试：**验证软件应用或系统的功能是否符合需求规格说明书或用户需求。功能测试的目的是：确保软件的每个功能都正常工作，并且满足用户的需求。测试人员会从用户的角度出发，模拟用户操作来验证软件的每个功能。

**集成测试：**发生在单元测试之后，目的是检查软件组件或模块在合并后作为一个整体时是否能够正常工作。集成测试确保各个组件之间的接口和交互能够按预期工作，并且整个系统作为一个协调一致的单元运行。

**压力测试：**评估软件在高负载或极端条件下的性能表现。目的是识别软件在极限工作条件下的瓶颈、稳定性问题以及可能的失败点。压力测试有助于提高软件的可靠性和用户满意度。

**回归测试：**验证软件在经过修改、更新或维护后，原有功能仍然按照预期工作，并且新引入的更改没有引入新的错误。回归测试是确保软件质量的重要环节。

**数据构造策略：**

- 手动构造：根据每个方法的JML规格，构造指令数较少但覆盖全面的测试数据，在构造时也需要构造边界数据。例如，作业说明书中要求`−1000≤social*_*value≤1000`，方法的JML中限制了正常情况下`tag.size()`的范围。手动构造的数据可以确保触发方法的每个分支（正常与异常情况），实现白箱测试。
- 随机生成：可以借助Random类生成随机数据，或使用DPO评测机。

上述两种数据构造策略需同时采用，才能达到更好的测试效果。

## 架构设计

本单元作业通过JML定义社交网络的基本功能规格，我们需要阅读JML，分析此社交网络，编写代码对其中的用户和他们之间的关系进行管理。我们需要在实现基础功能的前提下，利用不同的数据结构与算法对架构进行优化。

**hw9**

例如，本次作业中社交网络可以抽象为图论问题，在查找连通块时，可以通过维护并查集提高效率（需要在官方方法的基础上，设计辅助方法完成并查集，后文的bfs等同理）。在数据结构方面，虽然JML均采取数组表述，实际代码为了提升运行效率，会采取hashmap维护数据。

**hw10**

- 在计算最短路径时，采取bfs算法提高效率。

- getAgeMean()，ageSum在addPerson与delPerson时进行维护，提高效率。

- getBestId()，bestId需要在新增、修改或删除Acquaintance进行维护。


**hw11**

新增了Message等类，原有的Tag，Person与Network里的方法无变化，仅需要考虑新增的情况。

## 性能问题及其修复

超时问题，即在数据量过多，或重复指令操作时，若完全按照JML规格进行实现，评测会出现超时。在设计时需要将必要数据缓存，调用相关方法时直接返回答案。

这里写我的bug之一，如，queryTagValueSum指令时，若采取如下写法：

```java
int res = 0;
for (Integer id1 : persons.keySet()) {
    for (Integer id2 : persons.keySet()) {
        res += persons.get(id1).queryValue(persons.get(id2));
    }
}
return res;
```

符合JML，同时也符合超时。修改后发现，valueSum需要在Tag类里的addPerson、delPerson方法中维护，即将数据缓存。就算频繁调用queryTagValueSum指令，也不会超时。

## Junit

需要根据规格设计测试，实现对规格的一致性检查。

需要确保只修改`\assignable`允许修改的内容，每个`\ensure`均被测试。对于`pure`方法，需要保证对象中的所有成员均未被修改，在调用前后严格一致。

## 学习体会

通过本单元的学习，我了解了JML与Junit，并通过作业进行简单实践。第三单元与前两单元不同，此前的模式大致为：阅读指导书、理解需求、自行设计方法，实现代码并测试。而本单元的JML则限制了“方法设计”与“代码测试”，其中代码测试（这里指基于Junit的单元测试）严格约束于规格信息。若这是多人合作项目，在拥有基于自然语言书写的需求规格书的基础上，开发者与测试者可以借助JML协同工作，借助形式化表述提供工作效率，避免随意定义类或方法导致的架构混乱，白箱测试设计滞后的情况。

# 第四单元

## 正向建模与开发

OO第4单元实现了一个简单的图书馆管理系统，使用正向建模与开发的方式实现。正向建模与开发，即先根据作业指导书（需求文档）构建UML图，再依据UML图进行代码编写，有助于进行大型项目分析与规划。

## 本单元作业

在本单元作业中，我们实现的图书馆管理系统需要具备下列功能：查询书籍数、查询学生信用分数、借书、还书、预约书籍。

### 架构设计

以第一次作业为例，我设计了：

- Library：图书馆类，用于存储用户信息、在馆书籍信息。分配操作请求。
- Order：预约处，用于存储用户的预约信息，每次开馆时将可移动的在馆书籍移动到预约处。
- Borrow：借还处，用于处理借书与还书的请求
- Student：学生信息。
- OrderBook：基于基础Book类的OrderBook类，需要预约人信息，书号，预约日期等。


在之后两次作业中，我基于第一次作业，又增加了书籍漂流处、操作信息登记处等类，实现方式与此前基本一致，无大规模重构。对于容易出错的书籍移动环节，我设定闭馆后需要将借还处书籍全部送回书架，开馆时再分配预约书籍。通过严格的流程降低出错概率。

### 代码与UML模型关系

在写代码与画UML图前，我会设计简单流程图，这有助于我理清指导书思路。如图，是针对第二次作业整理的流程图。


## 架构设计思维

### 第一单元

**递归下降、OO入门：**第一单元的重点任务是解析与计算表达式，熟悉Java语法，以及建立面向对象的思维。难点在于递归下降方法，以及第一作业的架构设计（如果做的好，后续不需要完全重构，会节约很多时间）。

### 第二单元

**多线程：**实现模拟新主楼电梯调度系统。难点在于多线程的调试，以及bug较难复现。评测机在这一单元十分重要。

### 第三单元

**JML：**本单元主要通过阅读JML，编写对应的函数。个人认为这一单元最困难，JML给我体验很不好。本人认为仅依靠JML书写规格不太现实，实际开发中，JML应该和自然语言的说明一同出现，辅助开发者进行程序设计。

### 第四单元

**UML：**实现一个图书馆管理系统，在作业中要用到正向建模的方法。先根据作业指导书构建UML图，再依据UML图进行代码编写。

### 未来

依据个人浅薄的实习面试经历，第二单元中的多线程出现频率极高。在会用多线程锁的基础上，还需要阅读源码，能理解与讲清楚各种锁的区别。同时，各种细节问题也常被问到，如各类容器是如何实现的，源码有什么区别。JML相对来讲十分冷门，不会被问到；UML，我个人认为这是一种架构设计的思维，而非具体知识点，不会出现具体的问题。

我认为在此后的学习中，我更应该关注原理问题，而不是如何尽快让代码跑起来。

## 测试思维

第一、二单元主要借助了同学编写的评测机进行评测，同时手工编写了少量数据，用于开发过程中测试各单元功能。

第三单元做的不是很好，既没有用评测机、也没有自己测试过。

第四单元没有使用评测机，仅手工编写数据。因为第四单元作业逻辑较简单，且代码正确性也与自行设计的总流程有关，应该自行编写有逻辑的测试，而不是依靠评测机。

## 课程收获

很开心，2024年的OO课程结束了，我也表现得比预想中好。其实我本来应在去年修这门课，但去年第一次作业没有交上，再加上其他原因，我认为自己无法良好完成课程，遂退课。今年再选课时，我的能力较去年也有了一定提升，学习效果也好了很多。非常感谢老师、助教、以及同学们的帮助，同时感谢面对困难没有放弃的自己。